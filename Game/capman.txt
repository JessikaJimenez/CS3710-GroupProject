# Potential setup code
#########################################################################
# Start of program, sets up Capman game then proceeds with infinite loop
#
# %r1 - Capman State (1 is Capman is alive, 0 if Capman is dead)
# %r2 - Capman X Position (Cannot exceed 640)
# %r3 - Capman Y Position (Cannot exceed 480)
# %r4 - Capman Direction (0 = neutral, 1 = Down, 2 = Right, 3 = Left, 4 = Up, -1 = A)
# %r5 - Capman Position Jump (Determines speed, hardcoded to 1)
# %r6 - Ghost X Position (Cannot exceed 640)
# %r7 - Ghost Y Position (Cannot exceed 480)
# %r8 - Ghost Direction (0 = neutral, 1 = Down, 2 = Right, 3 = Left, 4 = Up, -1 = A)
# %r9 - Ghost Position Jump (Determines speed, hardcoded to 2)
.START # START OF GAME
MOVI %r1 $1 # r1 = 1 (alive)

# Capman starts at (320, 368) which is the top left of his sprite
MOVI %r2 $160 # r2 = 160
ASHUI %r2 $1 # r2 = 320 (Capman xPos)
MOVI %r3 $184 # r3 = 184
ASHUI %r3 $1 # r3 = 368 (Capman yPos)

MOVI %r4 $3 # r4 = Left (Capman Direction)
MOVI %r5 $1 # r5 = 1 (Capman Speed)

# Ghost starts at (304, 16) which is the top left of his sprite
MOVI %r6 $152 # r6 = 152
ASHUI %r6 $1 # r6 = 304 (xPosOnGhost)
MOVI %r7 $16 # r7 = 16 (yPosOnGhost)

MOVI %r8 $2 # r8 = Right (Ghost Direction)
MOVI %r9 $2 # r9 = 2 (Ghost Speed)

# Store starting information into memory
MOVI %r15 $48 # r15 = 0030
LUI %r15 $204 # r15 = CC30
STOR %r2 %r15 # Store xPos(320) into r15(CC30)
ADDI %r15 $1 # r15 = CC31
STOR %r3 %r15 # Store yPos(368) into r15(CC31)
ADDI %r15 $1 # r15 = CC32
STOR %r4 %r15 # Store Capman Direction (3) into r15(CC32)
ADDI %r15 $1 # r15 = CC33
STOR %r6 %r15 # Store xPosOnGhost(304) into r15(CC33)
ADDI %r15 $1 # r15 = CC34
STOR %r7 %r15 # Store yPosOnGhost(16) into r15(CC34)
ADDI %r15 $1 # r15 = CC35
STOR %r8 %r15 # Store Ghost Direction (2) into r15(CC35)
#######################################################################
# Infinite loop for game
.CHECKDIRECTION # Start of infinite loop for game, updates Capman based on direction pressed
MOV %r10 %r4 # r10 = r4 (store original direction)
MOVI %r15 $255 # r15 = 00FF
LUI %r15 $255 # r15 = FFFF
LOAD %r4 %r15 # Load user input into %r4
CMPI %r4 $0 
BGT $1 # If r4 is less than 0, execute next instruction which will keep capman going the same direction
MOV %r4 %r10 # r4 = r10 (original direction)
CMPI %r4 $1
BEQ .DOWN
CMPI %r4 $2
BEQ .RIGHT
CMPI %r4 $3
BEQ .LEFT
CMPI %r4 $4
BEQ .UP

.UPDATEGAME # Label for updating game, %r11 and %r12 are updated as Capman's position on grid

# Check for pacdot collision
MOVI %r15 .CHECKDOTCOLLISION # r15 = .CHECKDOTCOLLISION address
JAL %r0 %r15 # CALL .CHECKDOTCOLLISION (Returns %r10 as number of pacdots left)
CMPI %r10 $0
BEQ .ENDGAME # End the game if there are no pacdots left

# Update ghost position


# Check for ghost collision
.CHECKGHOSTCOLLISION
CMPI %r1 $0
BEQ .ENDGAME # End the game if Capman is dead
BUC .CHECKDIRECTION # Loop back to beginning
###########################################################################
# Function for when the player holds the left direction
# Capman will go left only if there are no collisions present
# If Capman reaches the edge of the screen, he will come out the other end
.LEFT
SUB %r2 %r5 # xPos -= Speed
CMPI %r2 $0
BGE .LEFTCONVERSION # If xPos < 0, don't need to check for collision
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
ADD %r2 %r15 # xPos += 640
.LEFTCONVERSION
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
ADD %r2 %r5 # Redo position update
BUC .UPDATEGAME
###############################################################################3
# Function for when the player holds the right direction
# Capman will go right only if there are no collisions present
# If Capman reaches the edge of the screen, he will come out the other end
.RIGHT
ADD %r2 %r5 # xPos += Speed
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
CMP %r2 %r15
BLT .RIGHTCONVERSION # If xPos >= 640, don't need to check for collision
SUB %r2 %r15 # xPos -= 640
.RIGHTCONVERSION
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
SUB %r2 %r5 # Redo position update
BUC .UPDATEGAME
##################################################################################
# Function for when the player holds the up direction
# Capman will go up only if there are no collisions present
.UP
ADD %r3 %r5 # yPos += Speed
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
SUB %r3 %r5 # Redo position update
BUC .UPDATEGAME
################################################################################
# Function for when the player holds the down direction
# Capman will go down only if there are no collisions present
.DOWN
SUB %r3 %r5 # yPos -= Speed
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
ADD %r3 %r5 # Redo position update
BUC .UPDATEGAME
###################################################################################
# This function converts the xPos and yPos of Capman to positions on a 40x30 grid
# Will update %r11 and %r12 to the positions on the grid
# 
# RETURNS
# %r11 as the xPosOnGrid
# %r12 as the yPosOnGrid
.CONVERTCAPMAN
MOV %r13 %r2 # r13 = xPos
MOV %r14 %r3 # r14 = yPos
CMPI %r4 $3
BGE .CONTINUECAPMANCONVERSION # Branch if direction is left or up, otherwise focus point must be on bottom right of sprite
ADDI %r13 $16 # r13 += 16
ADDI %r14 $16 # r14 += 16
.CONTINUECAPMANCONVERSION
MOV %r11 %r13 # r11 = xPos (top left or bottom right)
ASHUI %r11 $-4 # r11 /= 16
MOV %r12 %r14 # r12 = yPos (top left or bottom right)
ASHUI %r12 $-4 # r12 /= 16
JUC %r0
#####################################################################################
# This function converts the xPos and yPos of the ghost to positions on a 40x30 grid
# Will update %r11 and %r12 to the positions on the grid
#
# RETURNS
# %r11 as the xPosOnGrid
# %r12 as the yPosOnGrid
.CONVERTGHOST
MOV %r13 %r6 # r13 = xPosOnGhost
MOV %r14 %r7 # r14 = yPosOnGhost
CMPI %r8 $3
BGE .CONTINUEGHOSTCONVERSION # Branch if direction is left or up, otherwise focus point must be on bottom right of sprite
ADDI %r13 $16 # r13 += 16
ADDI %r14 $16 # r14 += 16
.CONTINUEGHOSTCONVERSION
MOV %r11 %r13 # r11 = xPosOnGhost (top left or bottom right)
ASHUI %r11 $-4 # r11 /= 16
MOV %r12 %r14 # r12 = yPosOnGhost (top left or bottom right)
ASHUI %r12 $-4 # r12 /= 16
JUC %r0
####################################################################################
# This function will check for a collision with a wall
# Uses %r11 and %r12 for positions on the grid
# 
# RETURNS
# %r10 - 1 if collides, 0 if not
.CHECKWALLCOLLISION
# Need to store the return address for the end of the function
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
STOR %r0 %r14 # Store last return address in memory

# Assume that capman does not collide
MOVI %r10 $0 # r10 = 0

# Get the sprite ID on the grid
MOVI %r15 .GETSPRITEID # r15 = .GETSPRITEID address
JAL %r0 %r15 # CALL .GETSPRITEID (Returns %r13 as sprite ID, won't use %r14)
CMPI %r13 $1
BLE .CHECKEDFORWALL # Branches if the block on grid isn't a wall
MOVI %r10 $1 # r10 = 1 (Player collides)
.CHECKEDFORWALL

# Return address was overwritten, get it back from memory
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
LOAD %r0 %r14 # Load last return address from memory
JUC %r0
####################################################################################
# This function will check for a pacdot collision
# If collides, removes pacdot from game and decrements counter
# Uses %r11 and %r12 for positions on the grid
#
# RETURNS
# %r10 - Number of pacdots left in the game
.CHECKDOTCOLLISION
# Need to store the return address for the end of the function
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
STOR %r0 %r14 # Store last return address in memory

# LOAD MEMORY FOR NUMBER OF PACDOTS IN GAME in %r10
MOVI %r15 .GETSPRITEID # r15 = .GETSPRITEID address
JAL %r0 %r15 # CALL .GETSPRITEID (Returns %r13 as sprite ID, %r14 as sprite ID address)
CMPI %r13 $1
BNE .CHECKEDFORDOT # Branches if block on grid isn't a pacdot
MOVI %r13 $0 # r13 = 0
STOR %r13 %r14 # Store r13(0) into the address in r14 (sprite ID address)
SUBI %r10 $1 # r10 -= 1
# STORE r10 (count - 1) in PACDOT COUNT
.CHECKEDFORDOT
# Return address was overwritten, get it back from memory
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
LOAD %r0 %r14 # Load last return address from memory
JUC %r0
####################################################################################
# This function will load a sprite ID based on %r11 and %r12
#
# RETURNS
# %r13 - Sprite ID at (%r11, %r12)
# %r14 - Sprite ID address
.GETSPRITEID
# Loads r13 from [C000 + xPosOnGrid + (40*yPosOnGrid)]
MOVI %r14 $0 # r14 = 0000
LUI %r14 $192 # r14 = C000
ADD %r14 %r11 # r14 += xPosOnGrid (C000 + xPosOnGrid)
MOVI %r15 $40 # r15 = 40
MUL %r15 %r12 # r15 *= yPosOnGrid
ADD %r14 %r15 # r14 += r15 (C000 + xPosOnGrid + (40*yPosOnGrid))
LOAD %r13 %r14 # Load memory at %r14 into %r13 (Sprite ID)
JUC %r0
####################################################################################
# This function will check for a ghost collision
# If a collision occurs, sets Capman's alive state to 0
.CHECKGHOSTCOLLISION
JUC %r0
####################################################################################
# This function is called when the user either wins or loses, allows to play again
.ENDGAME
CMPI %r1 $1
BEQ .ENDLOOP # Branches if Capman is still alive
# STORE CAPMAN'S STATE AS DEAD
.ENDLOOP
MOVI %r15 $255 # r15 = 00FF
LUI %r15 $255 # r15 = FFFF
LOAD %r4 %r15 # Load user input into %r4
CMPI %r4 $-1
BNE .ENDLOOP # Branches if user does not press A (play again button)
BUC .ENDGAME