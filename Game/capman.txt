# Potential setup code
#########################################################################
# Start of program, sets up Capman game then proceeds with infinite loop
#
# %r1 - Capman State (1 is Capman is alive, 0 if Capman is dead)
# %r2 - Capman X Position (Cannot exceed 640)
# %r3 - Capman Y Position (Cannot exceed 480)
# %r4 - Capman Direction (0 = neutral, 1 = Down, 2 = Right, 3 = Left, 4 = Up, -1 = A)
# %r5 - Ghost X Position (Cannot exceed 640)
# %r6 - Ghost Y Position (Cannot exceed 480)
# %r7 - Ghost Direction (1 = Down, 2 = Right, 3 = Left, 4 = Up)
.START # START OF GAME
MOVI %r1 $1 # r1 = 1 (alive)

# Capman starts at (320, 368) which is the top left of his sprite
MOVI %r2 $160 # r2 = 160
ASHUI %r2 $1 # r2 = 320 (Capman xPos)
MOVI %r3 $184 # r3 = 184
ASHUI %r3 $1 # r3 = 368 (Capman yPos)

MOVI %r4 $3 # r4 = Left (Capman Direction)

# Ghost starts at (304, 16) which is the top left of his sprite
MOVI %r5 $152 # r5 = 152
ASHUI %r5 $1 # r5 = 304 (xPosOnGhost)
MOVI %r6 $16 # r6 = 16 (yPosOnGhost)

MOVI %r7 $2 # r7 = Right (Ghost Direction)

# Store starting information into memory
MOVI %r15 $48 # r15 = 0030
LUI %r15 $204 # r15 = CC30
STOR %r2 %r15 # Store xPos(320) into r15(CC30)
ADDI %r15 $1 # r15 = CC31
STOR %r3 %r15 # Store yPos(368) into r15(CC31)
ADDI %r15 $1 # r15 = CC32
STOR %r4 %r15 # Store Capman Direction (3) into r15(CC32)
ADDI %r15 $1 # r15 = CC33
STOR %r5 %r15 # Store xPosOnGhost(304) into r15(CC33)
ADDI %r15 $1 # r15 = CC34
STOR %r6 %r15 # Store yPosOnGhost(16) into r15(CC34)
ADDI %r15 $1 # r15 = CC35
STOR %r7 %r15 # Store Ghost Direction (2) into r15(CC35)
ADDI %r15 $1 # r15 = CC36
MOVI %r8 $207 # r8 = 207
ASHUI %r8 $1 # r8 = 414
STOR %r8 %r15 # Store Pacdot Count (414) into r15(CC36)
ADDI %r15 $1 # r15 = CC37
STOR %r1 %r15 # Store Pacman State (1) into r15(CC37)
#######################################################################
# Infinite loop for game
.CHECKDIRECTION # Start of infinite loop for game, updates Capman based on direction pressed
MOVI %r15 $255 # r15 = 00FF
LUI %r15 $255 # r15 = FFFF
LOAD %r8 %r15 # Load user input into %r8
CMPI %r8 $0 
BLE $1 # If r4 greater than 0, execute next instruction which will overwrite capman's direction
MOV %r4 %r8 # r4 = r8
CMPI %r4 $1
BEQ .CAPMANDOWN
CMPI %r4 $2
BEQ .CAPMANRIGHT
CMPI %r4 $3
BEQ .CAPMANLEFT
CMPI %r4 $4
BEQ .CAPMANUP

.UPDATEGAME # Label for updating game, %r11 and %r12 are updated as Capman's position on grid

# Check for pacdot collision
MOVI %r15 .CHECKDOTCOLLISION # r15 = .CHECKDOTCOLLISION address
JAL %r0 %r15 # CALL .CHECKDOTCOLLISION (Returns %r10 as number of pacdots left)
CMPI %r10 $0
BEQ .ENDGAME # End the game if there are no pacdots left

# Update ghost position based on its current direction
# If the ghost collides, goes back to this label with a new direction
.UPDATEGHOST
CMPI %r7 $1
BEQ .GHOSTDOWN
CMPI %r7 $2
BEQ .GHOSTRIGHT
CMPI %r7 $3
BEQ .GHOSTLEFT
CMPI %r7 $4
BEQ .GHOSTUP

# Check if Capman has died, if so end the game
.CAPMANSTATE
MOVI %r15 .CHECKGHOSTCOLLISION # r15 = .CHECKGHOSTCOLLISION address
JAL %r0 %r15 # Call .CHECKGHOSTCOLLISION (Will update r1 if characters hit each other)
CMPI %r1 $0
BEQ .ENDGAME # End the game if Capman is dead
BUC .CHECKDIRECTION # Loop back to beginning
###########################################################################
# Function for character going the left direction
# Goes left if there are no collisions present
# If a character reaches the edge of the screen, they will come out the other end
.CAPMANLEFT
SUBI %r2 $1 # xPos -= 1
CMPI %r2 $0
BGE .LEFTCONVERSION # Execute next few instruction if we need to loop
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
ADD %r2 %r15 # xPos += 640
.LEFTCONVERSION
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
ADDI %r2 $1 # Redo position update
BUC .UPDATEGAME
###############################################################################3
# Function for when the player holds the right direction
# Capman will go right only if there are no collisions present
# If Capman reaches the edge of the screen, he will come out the other end
.CAPMANRIGHT
ADDI %r2 $1 # xPos += 1
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
CMP %r2 %r15
BLT .RIGHTCONVERSION # Execute next instruction if we need to loop
SUB %r2 %r15 # xPos -= 640
.RIGHTCONVERSION
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
SUBI %r2 $1 # Redo position update
BUC .UPDATEGAME
##################################################################################
# Function for when the player holds the up direction
# Capman will go up only if there are no collisions present
.CAPMANUP
SUBI %r3 $1 # yPos -= 1
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
ADDI %r3 $1 # Redo position update
BUC .UPDATEGAME
################################################################################
# Function for when the player holds the down direction
# Capman will go down only if there are no collisions present
.CAPMANDOWN
ADDI %r3 $1 # yPos += 1
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
SUBI %r3 $1 # Redo position update
BUC .UPDATEGAME
###################################################################################
# Function for when the ghost goes left
# The ghost will go left only if there are no collisions present
# Otherwise, it picks a new direction
.GHOSTLEFT
SUBI %r5 $2 # xPosOnGhost -= 2
CMPI %r5 $0
BGE .LEFTCONVERSIONGHOST # Execute next few instruction if we need to loop
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
ADD %r5 %r15 # xPosOnGhost += 640
.LEFTCONVERSIONGHOST
MOVI %r15 .CONVERTGHOST # r15 = .CONVERTGHOST address
JAL %r0 %r15 # CALL .CONVERTGHOST (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .CAPMANSTATE # Branches if the ghost does not collide
ADDI %r5 $2 # Redo position update

# Need to pick new direction, either up or down
BUC .UPORDOWN
###################################################################################
# Function for when the ghost goes right
# The ghost will go right only if there are no collisions present
# Otherwise, it picks a new direction
.GHOSTRIGHT
ADDI %r5 $2 # xPosOnGhost += 2
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
CMP %r5 %r15
BLT .RIGHTCONVERSION # Execute next instruction if we need to loop
SUB %r5 %r15 # xPosOnGhost -= 640
.RIGHTCONVERSIONGHOST
MOVI %r15 .CONVERTGHOST # r15 = .CONVERTGHOST address
JAL %r0 %r15 # CALL .CONVERTGHOST (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .CAPMANSTATE # Branches if the ghost does not collide
SUBI %r5 $2 # Redo position update

# Need to pick new direction, either up or down
BUC .UPORDOWN
##################################################################################
# Function for when the ghost goes up
# The ghost will go up only if there are no collisions present
# Otherwise, it picks a new direction
.GHOSTUP
SUBI %r6 $2 # yPosOnGhost -= 2
MOVI %r15 .CONVERTGHOST # r15 = .CONVERTGHOST address
JAL %r0 %r15 # CALL .CONVERTGHOST (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .CAPMANSTATE # Branches if the ghost does not collide
ADDI %r6 $2 # Redo position update

# Need to pick new direction, either left or right
BUC .LEFTORRIGHT
###################################################################################
# Function for when the ghost goes down
# The ghost will go down only if there are no collisions present
# Otherwise, it picks a new direction
.GHOSTDOWN
ADDI %r6 $2 # yPosOnGhost += 2
MOVI %r15 .CONVERTGHOST # r15 = .CONVERTGHOST address
JAL %r0 %r15 # CALL .CONVERTGHOST (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .CAPMANSTATE # Branches if the ghost does not collide
SUBI %r6 $2 # Redo position update

# Need to pick new direction, either left or right
BUC .LEFTORRIGHT
###################################################################################
# This function will pick a new direction for the ghost, either up or down
# The logic for this will determine on the current direction capman is going
# If capman is going up, the ghost will go down (and vice versa)
.UPORDOWN
CMPI %r4 $4
BEQ .GOESUP
MOVI %r7 $4 # Capman is going down, so the ghost will go up
BUC .UPDATEGHOST
.GOESUP
MOVI %r7 $0 # Capman is going up, so the ghost will go down
BUC .UPDATEGHOST
###################################################################################
# This function will pick a new direction for the ghost, either left or right
# The logic for this will determine on the current direction capman is going
# If capman is going left, the ghost will go right (and vice versa)
.LEFTORRIGHT
CMPI %r4 $2
BEQ .GOESRIGHT
MOVI %r7 $2 # Capman is going left, so the ghost will go right
BUC .UPDATEGHOST
.GOESRIGHT
MOVI %r7 $3 # Capman is going right, so the ghost will go left
BUC .UPDATEGHOST
###################################################################################
# This function converts the xPos and yPos of Capman to positions on a 40x30 grid
# Will update %r11 and %r12 to the positions on the grid
# 
# RETURNS
# %r11 as the xPosOnGrid
# %r12 as the yPosOnGrid
.CONVERTCAPMAN
MOV %r13 %r2 # r13 = xPos
MOV %r14 %r3 # r14 = yPos
CMPI %r4 $3
BGE .CONTINUECAPMANCONVERSION # Branch if direction is left or up, otherwise focus point must be on bottom right of sprite
ADDI %r13 $16 # r13 += 16
ADDI %r14 $16 # r14 += 16
.CONTINUECAPMANCONVERSION
MOV %r11 %r13 # r11 = xPos (top left or bottom right)
ASHUI %r11 $-4 # r11 /= 16
MOV %r12 %r14 # r12 = yPos (top left or bottom right)
ASHUI %r12 $-4 # r12 /= 16
JUC %r0
#####################################################################################
# This function converts the xPos and yPos of the ghost to positions on a 40x30 grid
# Will update %r11 and %r12 to the positions on the grid
#
# RETURNS
# %r11 as the xPosOnGrid
# %r12 as the yPosOnGrid
.CONVERTGHOST
MOV %r13 %r5 # r13 = xPosOnGhost
MOV %r14 %r6 # r14 = yPosOnGhost
CMPI %r7 $3
BGE .CONTINUEGHOSTCONVERSION # Branch if direction is left or up, otherwise focus point must be on bottom right of sprite
ADDI %r13 $16 # r13 += 16
ADDI %r14 $16 # r14 += 16
.CONTINUEGHOSTCONVERSION
MOV %r11 %r13 # r11 = xPosOnGhost (top left or bottom right)
ASHUI %r11 $-4 # r11 /= 16
MOV %r12 %r14 # r12 = yPosOnGhost (top left or bottom right)
ASHUI %r12 $-4 # r12 /= 16
JUC %r0
####################################################################################
# This function will check for a collision with a wall
# Uses %r11 and %r12 for positions on the grid
# 
# RETURNS
# %r10 - 1 if collides, 0 if not
.CHECKWALLCOLLISION
# Need to store the return address for the end of the function
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
STOR %r0 %r14 # Store last return address in memory

# Assume that capman does not collide
MOVI %r10 $0 # r10 = 0

# Get the sprite ID on the grid
MOVI %r15 .GETSPRITEID # r15 = .GETSPRITEID address
JAL %r0 %r15 # CALL .GETSPRITEID (Returns %r13 as sprite ID, won't use %r14)
CMPI %r13 $1
BLE .CHECKEDFORWALL # Branches if the block on grid isn't a wall
MOVI %r10 $1 # r10 = 1 (Player collides)
.CHECKEDFORWALL

# Return address was overwritten, get it back from memory
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
LOAD %r0 %r14 # Load last return address from memory
JUC %r0
####################################################################################
# This function will check for a pacdot collision
# If collides, removes pacdot from game and decrements counter
# Uses %r11 and %r12 for positions on the grid
#
# RETURNS
# %r10 - Number of pacdots left in the game
.CHECKDOTCOLLISION
# Need to store the return address for the end of the function
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
STOR %r0 %r14 # Store last return address in memory

# Load the number of pacdots in the game into %r10
MOVI %r9 $54 # r9 = 0036
LUI %r9 $204 # r9 = CC36
LOAD %r10 %r9 # Load memory at r9(CC36) into r10 (number of pacdots)
MOVI %r15 .GETSPRITEID # r15 = .GETSPRITEID address
JAL %r0 %r15 # CALL .GETSPRITEID (Returns %r13 as sprite ID, %r14 as sprite ID address)
CMPI %r13 $1
BNE .CHECKEDFORDOT # Branches if block on grid isn't a pacdot
MOVI %r13 $0 # r13 = 0
STOR %r13 %r14 # Store r13(0) into the address in r14 (sprite ID address)
SUBI %r10 $1 # r10 -= 1
STOR %r10 %r9 # Decrement pacdot count in memory
.CHECKEDFORDOT
# Return address was overwritten, get it back from memory
MOVI %r14 $254 # r14 = 00FE
LUI %r14 $255 # r14 = FFFE
LOAD %r0 %r14 # Load last return address from memory
JUC %r0
####################################################################################
# This function will load a sprite ID based on %r11 and %r12
#
# RETURNS
# %r13 - Sprite ID at (%r11, %r12)
# %r14 - Sprite ID address
.GETSPRITEID
# Loads r13 from [C000 + xPosOnGrid + (40*yPosOnGrid)]
MOVI %r14 $0 # r14 = 0000
LUI %r14 $192 # r14 = C000
ADD %r14 %r11 # r14 += xPosOnGrid (C000 + xPosOnGrid)
MOVI %r15 $40 # r15 = 40
MUL %r15 %r12 # r15 *= yPosOnGrid
ADD %r14 %r15 # r14 += r15 (C000 + xPosOnGrid + (40*yPosOnGrid))
LOAD %r13 %r14 # Load memory at %r14 into %r13 (Sprite ID)
JUC %r0
####################################################################################
# This function will check for a ghost collision
# If a collision occurs, sets Capman's alive state to 0
.CHECKGHOSTCOLLISION
JUC %r0
####################################################################################
# This function is called when the user either wins or loses, allows to play again
.ENDGAME
MOVI %r15 $55 # r15 = 0037
LUI %r15 $204 # r15 = CC37
STOR %r1 %r15 # Store Capman's state into memory, whether alive or dead
MOVI %r15 $255 # r15 = 00FF
LUI %r15 $255 # r15 = FFFF
.ENDLOOP
LOAD %r4 %r15 # Load user input into %r4
CMPI %r4 $-1
BNE .ENDLOOP # Branches if user does not press A (play again button)
BUC .ENDGAME