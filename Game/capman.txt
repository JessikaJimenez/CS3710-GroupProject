# Potential setup code
#########################################################################
# Start of program, sets up Capman game then proceeds with infinite loop
#
# %r1 - Capman State (1 is Capman is alive, 0 if Capman is dead)
# %r2 - Capman X Position (Cannot exceed 640)
# %r3 - Capman Y Position (Cannot exceed 480)
# %r4 - Capman Direction (0 = neutral, 1 = Down, 2 = Right, 3 = Left, 4 = Up, -1 = A)
# %r5 - Capman Position Jump (Determines speed, hardcoded to 1)
# %r6 - Ghost X Position (Cannot exceed 640)
# %r7 - Ghost Y Position (Cannot exceed 480)
# %r8 - Ghost Direction (0 = neutral, 1 = Down, 2 = Right, 3 = Left, 4 = Up, -1 = A)
# %r9 - Ghost Position Jump (Determines speed, hardcoded to 2)
.START # START OF GAME
MOVI %r1 $1 # r1 = 1 (alive)

# Capman starts at (300, 240) which is the top left of his sprite
MOVI %r2 $150 # r2 = 150
ASHUI %r2 $1 # r2 = 300 (Capman xPos)
MOVI %r3 $240 # r3 = 240 (Capman yPos)

MOVI %r4 $3 # r4 = Left (Capman Direction)
MOVI %r5 $1 # r5 = 1 (Capman Speed)

# Ghost starts at (320, 20) which is the top left of his sprite
MOVI %r6 $160 # r6 = 160
ASHUI %r6 $1 # r6 = 320 (Ghost xPos)
MOVI %r7 $20 # r7 = 20 (Ghost yPos)

MOVI %r8 $2 # r8 = Right (Ghost Direction)
MOVI %r9 $2 # r9 = 2 (Ghost Speed)
#######################################################################
# Infinite loop for game
.CHECKDIRECTION # Start of infinite loop for game, updates Capman based on direction pressed
MOV %r10 %r4 # r10 = r4 (store original direction)
MOVI %r15 $-1 # r15 = 00FF
LUI %r15 $-1 # r15 = FFFF
LOAD %r4 %r15 # Load user input into %r4
CMPI %r4 $0 
BGT $1 # If r4 is less than 0, execute next instruction which will keep capman going the same direction
MOV %r4 %r10 # r4 = r10 (original direction)
CMPI %r4 $1
BEQ .DOWN
CMPI %r4 $2
BEQ .RIGHT
CMPI %r4 $3
BEQ .LEFT
CMPI %r4 $4
BEQ .UP

.UPDATEGAME # Label for updating game, %r11 and %r12 are updated as Capman's position on grid

# Check for pacdot collision
MOVI %r15 .CHECKDOTCOLLISION # r15 = .CHECKDOTCOLLISION address
JAL %r0 %r15 # CALL .CHECKDOTCOLLISION (Returns %r10 as number of pacdots left)
CMPI %r10 $0
BEQ .ENDGAME # End the game if there are no pacdots left

# Update ghost position


# Check for ghost collision
.CHECKGHOSTCOLLISION
CMPI %r1 $0
BEQ .ENDGAME # End the game if Capman is dead
BUC .CHECKDIRECTION # Loop back to beginning
###########################################################################
# Function for when the player holds the left direction
# Capman will go left only if there are no collisions present
# If Capman reaches the edge of the screen, he will come out the other end
.LEFT
SUB %r2 %r5 # xPos -= Speed
CMPI %r2 $0
BGE .LEFTCONVERSION # If xPos < 0, don't need to check for collision
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
ADD %r2 %r15 # xPos += 640
.LEFTCONVERSION
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
ADD %r2 %r5 # Redo position update
BUC .UPDATEGAME
###############################################################################3
# Function for when the player holds the right direction
# Capman will go right only if there are no collisions present
# If Capman reaches the edge of the screen, he will come out the other end
.RIGHT
ADD %r2 %r5 # xPos += Speed
MOVI %r15 $160 # %r15 = 160
ASHUI %r15 $2 # r15 = 640
CMP %r2 %r15
BLT .RIGHTCONVERSION # If xPos >= 640, don't need to check for collision
SUB %r2 %r15 # xPos -= 640
.RIGHTCONVERSION
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
SUB %r2 %r5 # Redo position update
BUC .UPDATEGAME
##################################################################################
# Function for when the player holds the up direction
# Capman will go up only if there are no collisions present
.UP
ADD %r3 %r5 # yPos += Speed
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
SUB %r3 %r5 # Redo position update
BUC .UPDATEGAME
################################################################################
# Function for when the player holds the down direction
# Capman will go down only if there are no collisions present
.DOWN
SUB %r3 %r5 # yPos -= Speed
MOVI %r15 .CONVERTCAPMAN # r15 = .CONVERTCAPMAN address
JAL %r0 %r15 # CALL .CONVERTCAPMAN (Returns %r11 and %r12 as positions on grid)
MOVI %r15 .CHECKWALLCOLLISION # r15 = .CHECKWALLCOLLISION address
JAL %r0 %r15 # CALL .CHECKWALLCOLLISION (Returns %r10 as collision detection)
CMPI %r10 $0
BEQ .UPDATEGAME # Branches if capman does not collide
ADD %r3 %r5 # Redo position update
BUC .UPDATEGAME
###################################################################################
# This function converts the xPos and yPos of Capman to positions on a 40x30 grid
# Will update %r11 and %r12 to the positions on the grid
# 
# RETURNS
# %r11 as the xPosOnGrid
# %r12 as the yPosOnGrid
.CONVERTCAPMAN
MOV %r13 %r2 # r13 = xPos
MOV %r14 %r3 # r14 = yPos
CMPI %r4 $3
BGE .CONTINUECAPMANCONVERSION # Branch if direction is left or up, otherwise focus point must be on bottom right of sprite
ADDI %r13 $16 # r13 += 16
ADDI %r14 $16 # r14 += 16
.CONTINUECAPMANCONVERSION
MOV %r11 %r13 # r11 = xPos (top left or bottom right)
ASHUI %r11 $-4 # r11 /= 16
MOV %r12 %r14 # r12 = yPos (top left or bottom right)
ASHUI %r12 $-4 # r12 /= 16
JUC %r0
#####################################################################################
# This function converts the xPos and yPos of the ghost to positions on a 40x30 grid
# Will update %r11 and %r12 to the positions on the grid
#
# RETURNS
# %r11 as the xPosOnGrid
# %r12 as the yPosOnGrid
.CONVERTGHOST
MOV %r13 %r6 # r13 = xPosOnGhost
MOV %r14 %r7 # r14 = yPosOnGhost
CMPI %r8 $3
BGE .CONTINUEGHOSTCONVERSION # Branch if direction is left or up, otherwise focus point must be on bottom right of sprite
ADDI %r13 $16 # r13 += 16
ADDI %r14 $16 # r14 += 16
.CONTINUEGHOSTCONVERSION
MOV %r11 %r13 # r11 = xPosOnGhost (top left or bottom right)
ASHUI %r11 $-4 # r11 /= 16
MOV %r12 %r14 # r12 = yPosOnGhost (top left or bottom right)
ASHUI %r12 $-4 # r12 /= 16
JUC %r0
####################################################################################
# This function will check for a collision with a wall
# Uses %r11 and %r12 for positions on the grid
# 
# RETURNS
# %r10 - 1 if collides, 0 if not
.CHECKWALLCOLLISION
MOVI %r10 $0 # r10 = 0
# LOAD MEMORY FOR GRID POSITION ID in %r13
CMPI %r13 $1
BLE .CHECKEDFORWALL # Branches if the block on grid isn't a wall
MOVI %r10 $1 # r10 = 1
.CHECKEDFORWALL
JUC %r0
####################################################################################
# This function will check for a pacdot collision
# If collides, removes pacdot from game and decrements counter
# Uses %r11 and %r12 for positions on the grid
#
# RETURNS
# %r10 - Number of pacdots left in the game
.CHECKDOTCOLLISION
# LOAD MEMORY FOR NUMBER OF PACDOTS IN GAME in %r10
# LOAD MEMORY FOR GRID POSITION ID in %r13
CMPI %r13 $1
BNE .CHECKEDFORDOT # Branches if block on grid isn't a pacdot
MOVI %r13 $0 # r13 = 0
# STORE r13 (0) in GRID POSITION ID
SUBI %r10 $1 # r10 -= 1
# STORE r10 (count - 1) in PACDOT COUNT
.CHECKEDFORDOT
JUC %r0
####################################################################################
# This function will check for a ghost collision
# If a collision occurs, sets Capman's alive state to 0
.CHECKGHOSTCOLLISION
JUC %r0
####################################################################################
# This function is called when the user either wins or loses, allows to play again
.ENDGAME
# Get input from I/O, if it is start...
BUC .START